(window.webpackJsonp=window.webpackJsonp||[]).push([[215],{684:function(t,v,_){"use strict";_.r(v);var r=_(32),n=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[t._v("#")]),t._v(" 二叉树")]),t._v(" "),_("p",[t._v("这种树的每 个节点"),_("strong",[t._v("最多")]),t._v("有2个孩子节点"),_("br"),t._v("\n二叉树的两个节点，一个叫左孩子、一个叫右孩子")]),t._v(" "),_("h2",{attrs:{id:"类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[t._v("#")]),t._v(" 类型")]),t._v(" "),_("ul",[_("li",[t._v("满二叉树"),_("br"),t._v("\n一个二叉树的所有非叶子节点都存在左右孩子"),_("br"),t._v("\n所有的叶子节点都在同一层级")]),t._v(" "),_("li",[t._v("完全二叉树\n对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个 二叉树为完全二叉树"),_("br"),t._v("\n完全二叉树只需保证最后一个节点之前的节点都齐全即可")]),t._v(" "),_("li",[t._v("二叉查找树\n如果左子树不为空，则左子树上所有节点的值均小于根节点的值"),_("br"),t._v("\n如果右子树不为空，则右子树上所有节点的值均大于根节点的值"),_("br"),t._v("\n左、右子树也都是二叉查找树")])]),t._v(" "),_("h2",{attrs:{id:"作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),_("p",[t._v("主要应用于查找和维持相对顺序")]),t._v(" "),_("p",[t._v("二叉树的自平衡")]),t._v(" "),_("ul",[_("li",[t._v("红黑树")]),t._v(" "),_("li",[t._v("AVL树")]),t._v(" "),_("li",[t._v("树堆")]),t._v(" "),_("li",[t._v("...")])])])}),[],!1,null,null,null);v.default=n.exports}}]);