(window.webpackJsonp=window.webpackJsonp||[]).push([[332],{808:function(o,l,n){"use strict";n.r(l);var t=n(32),s=Object(t.a)({},(function(){var o=this.$createElement,l=this._self._c||o;return l("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[l("h1",{attrs:{id:"symbol"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[this._v("#")]),this._v(" Symbol")]),this._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[this._v('1、概述\n是一种新的数据类型，表示独一无二的值\n通过 Symbol 函数生成，前面不加 new\nlet s = Symbol(); typeof s // "symbol"\nSymbol（参数） 接收一个参数，表示对当前Symbol值的描述\nlet s = Symbol("foo"); typeof s // "symbol(foo)"\n只能转化为字符串和布尔值\nlet s = Symbol("foo") s.toString(); // "symbol(foo)"\n!s // false\n2、作为属性名\n三种写法\nvar mySymbol = Symbol();\n//第一种\nvar a = {};\na[mySymbol] = \'\'hello\'\';\n//第二种\nvar a = {\n[mySymbol]："hello";\n}\n注意，Symbol值作对象的属性名时，不能用点运算符，必须用括号 []\n用于定义常量，变量的时候，每个都是不相同的\n3、消除魔术字符串\n魔术字符串：在程序中多次出现的一个字符串，最好将这个字符串用一个语义化的变量保存\n变量的值等于什么不重要 var 变量 = Symbol();\n4、属性名的遍历\nSymbol作为属性名，不会出现在for...in，for...of循环中，也不会被Object.keys()、Object.getOwnPropetyNames()返回，但是它不是私有属性\nObject.getOwnPropetySymbols()方法返回一个数组，成员是当前对象所有用于属性名的Symbol值\n利用这个特性，可以为对象定义一些非私有的，用于内部的方法\n5、Symbol.for() Symbol.keyFor()\nSymbol.for(参数) 在全局环境中搜索，如果有，返回该Symbol值，若没有，返回一个新建的值\nSymbol.for(Symbol值) 返回已登记的Symbol类型值的key （已登记：用Symbol.for()生成的）\nvar s1 = Symbol("foo"); Symbol.keyFor(s1) // undefined\nvar s2 = Symbol("foo"); Symbol.keyFor(s2) // foo\n')])])])])}),[],!1,null,null,null);l.default=s.exports}}]);