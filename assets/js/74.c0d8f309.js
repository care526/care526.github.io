(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{540:function(e,t,o){"use strict";o.r(t);var r=o(32),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"module"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#module"}},[e._v("#")]),e._v(" module")]),e._v(" "),o("h2",{attrs:{id:"commonjs"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[e._v("#")]),e._v(" CommonJS")]),e._v(" "),o("blockquote",[o("p",[e._v('对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值\n对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块\n当使用require命令加载某个模块时，就会运行整个模块的代码\n当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存\n循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出')])]),e._v(" "),o("ol",[o("li",[e._v("代码走到require的时候才会执行")]),e._v(" "),o("li",[e._v("模块代码只会执行一次，模块导出被缓存")])]),e._v(" "),o("h2",{attrs:{id:"esmodule"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#esmodule"}},[e._v("#")]),e._v(" esModule")]),e._v(" "),o("blockquote",[o("p",[e._v("ES6模块中的值属于【动态只读引用】\n对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值\n对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型\n循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行")])]),e._v(" "),o("ol",[o("li",[e._v("模块导出的只是一个内存地址，代码运行到了，去内存里面去取，所以是动态不确定的")])])])}),[],!1,null,null,null);t.default=s.exports}}]);